# Chapter 1. 컴퓨터 추상화 및 관련 기술

## 1.1 서론

저자는 Moore라는 사람을 좋아하는 것 같다. 

**이 책에서는 어떤 것을 배울 수 있는가**<br>

- C나 Java 같은 상위 수준 언어로 작성된 프로그램이 어떻게 하드웨어 언어로 번역되며, 하드웨어는 번역된 프로그램을 어떻게 실행하는가?
- 소프트웨어와 하드웨어 사이의 인터페이스는 무엇이며, 소프트웨어는 어떻게 필요한 일을 하드웨어에게 지시하는가?
- 프로그램의 성능을 결정하는 요소는 무엇이며, 프로그래머는 어떻게 성능을 개선할 수 있는가?
- 성능 개선을 위해 하드웨어 설계자는 어떤 기술을 사용할 수 있는가?
- 에너지 효율성을 개선하기 위해 하드웨어 설계자는 어떤 기술을 사용할 수 있는가?
- 최근 순차적인 처리에서 병렬 처리로 넘어가는 이유는 무엇이며 그 결과는 어떠한가?
- 1951년에 최초로 컴퓨터가 시판된 이후 컴퓨터 구조 분야의 어떤 위대한 아이디어들이 현대 컴퓨팅의 기초를 닦았는가?

**프로그램 성능의 이해**

프로그램의 성능은 사용된 알고리즘의 효율성과 프로그램을 생성하고 기계어로 변역하는 데 사용된 소프트웨어 시스템, 입출력(I/O) 작업을 포함하여 번역된 명령어를 실행하는 컴퓨터의 효율성에 의해 결정된다.

| 하드웨어 또는 소프트웨어 구성 요소 | 성능에 미치는 영향 | 관련 부분 |
|:----------:|:----------:|:----------:|
| 알고리즘 | 소스 프로그램 문장 수와 입출력 작업수를 결정 | 다른 책 |
| 프로그래밍 언어, 컴파일러, 컴퓨터 구조 | 각 소스 프로그램 문장에 해당하는 기계어 명령어 수 결정 | 2, 3장 |
| 프로세서와 메모리 시스템 | 명령어의 실행 속도 결정 | 4, 5, 6장 |
| 입출력 시스템 (하드웨어 및 운영체제) | 입출력 작업의 실행 속도 결정 | 4, 5, 6장 |

## 1.2 컴퓨터 구조 분야의 8가지 위대한 아이디어

**Moore의 법칙을 고려한 설계** <br>
18~24개월마다 칩에 집적되는 소자의 수가 2배 가량 빠르게 변화하므로(Moore의 법칙), 컴퓨터 설계자는 프로젝트의 시작 시점보다 종료 시점의 기술을 예상해야 한다.

**설계를 단순화하는 추상화(abstraction)** <br>
하위 수준의 상세한 사항을 안보이게 함으로써 상위 수준 모델을 단순화한다.

**자주 생기는 일을 빠르게(common case fast)** <br>
드물게 생기는 일을 최적화하는 것보다 자주생기는 일을 빠르게 만드는 것이 성능 개선에 도움이 된다.

**병렬성을 통한 성능 개선** <br>

**파이프라이닝(pipelining)을 통한 성능 개선** <br>
~~불을 끌 때 사람들이 길게 늘어서서 양동이로 물을 나르는 느낌이라는데 아직 느낌인지 모르겠다.~~ 코드를 부분 부분 나눠서 덩어리들을 잇는 느낌.

**예측을 통한 성능개선** <br>
예측을 잘못해서 이를 복구하는 비용이 비싸지 않고 예측이 성공할 확률이 비교적 높은 경우, 예측을 해서 미리 일을 수행하는 것이 평균적으로 빠른 경우가 종종 있다.

**메모리 계층구조** <br>
최상위 계층에는 비트당 가격이 제일 비싸지만 작고 빠르 메모리를 사용하고, 최하위 계층에는 느리지만 크고 비트당 가격이 제일 싼 메모리를 사용한다.

**여유분을 이용한 신용도 개선** <br>
모든 물리 소자는 장애가 발생할 수 있으므로, 장애를 감지하고 장애가 난 소자를 대치할 수 있도록 여유분을 준비하면 컴퓨터 신용도(dependability)를 개선할 수 있다.

## 1.3 프로그램 밑의 세계

컴퓨터 하드웨어는 아주 단순한 저수준의 명령어만 실행할 수 있다. 복잡한 응용에서 출발해서 단순한 명령어까지 내려가려면 높은 수준의 작업을 단순한 컴퓨터 명령어로 번역 또는 해독하는 여러 겹의 소프트웨어가 필요하다. 이것이 **추상화**이다.<br>
<br>
소프트웨어는 계층적으로 구성된다. 하드웨어가 가장 안쪽의 계층이라고 하고, 응용 소프트웨어를 가장 바깥쪽의 계층이라고 하면, 그 사이에 여러 가지 시스템 소프트웨어들이 존재한다. <br>
<br>
오늘날 컴퓨터 시스템에서 핵심이 되는 두 가지는 운영체제와 컴파일러이다. <br> 운영체제는 사용자 프로그램과 하드웨어 간의 인터페이스 역할을 하면서 각종 서비스와 감독 기능을 제공한다. (기본적 입출력 작업의 처리, 보조기억장치 및 메모리 할당, 컴퓨터를 동시에 사용하는 여러 응용들 간의 컴퓨터 공유 방법 제공) <br>
컴파일러는 C, C++ 같은 상위 수준 언어로 작성된 프로그램을 하드웨어가 실행할 수 있는 명령어로 번역하는 일을 한다.

**상위 수준에서 기계어까지**

- 기계어(machine language): 기계 명령어(하드웨어가 이해하고 수행하는 명령)의 이진 표현. (0과 1로 이루어져있음.)
- 어셈블러(assembler): 기호로 된 명령어(어셈블리 언어)를 이진수 프로그램으로 번역하는 프로그램.
- 상위 수준 언어(high-level programming language): C, C++ 같이 단어와 수식으로 구성되는 이식성이 있는 언어. 컴파일러가 어셈블리 언어로 번역할 수 있다.

## 1.4 케이스를 열고

하드웨어에 대해 알아보자. 컴퓨터 하드웨어는 데이터 입력, 데이터 출력, 데이터 처리, 데이터 저장의 네 가지 기본 기능을 수행한다. <br>
<br>
컴퓨터의 고전적 구성 요소 다섯 가지는 입력, 출력, 메모리, 데이터패스(datapath), 제어(control) 유닛이다. 이 중 마지막 두개는 합쳐서 프로세서(processor)라고 한다. <br>
<br>
입력장치, 출력장치는 뭔지 대충알고, <br>
<br>
프로세서는 프로그램의 지시대로 일을 하는 부분으로 보드 내에서 가장 역동적인 부분이다. CPU(central processor unit)라고 부르기도 한다. 프로세서는 논리적으로 데이터패스와 제어 유닛의 두 부분으로 구성된다. 데이터패스는 연산을 수행하고, 제어 유닛은 명령어가 뜻하는 바에 따라 데이터패스, 메모리, 입출력장치가 할 일을 지시한다. <br>
<br>
메모리는 실행 중인 프로그램과 프로그램이 필요로 하는 데이터를 기억한다. 메모리는 DRAM(dynamic random access memory)칩으로 구성되어 있다. DRAM 여러 개를 한데 묶어서 프로그램의 명령어와 데이터를 기억하는 데 사용한다. DRAM에서 RAM이란 말은 자기 테이프 같은 순차 접근 메모리와는 반대로 메모리의 어떤 부분을 읽든지 같은 시간이 걸린다는 것을 의미한다. <br>
프로세서 내부에는 캐시 메모리(cache memory)라는 또 다른 종류의 메모리도 있는데, 이 캐시 메모리는 DRAM의 버퍼 역할을 하는 작고 빠른 메모리이다. 캐시는 SRAM(static random access memory)이라는 다른 메모리 기술을 이용한다. SRAM은 DRAM보다 빠르지만 집적도가 낮아서 가격이 비싸다. SRAM과 DRAM은 메모리 계층구조의 위 두 계층을 구성한다. <br>
<br>
DRAM은 컴퓨터 전원이 공급되는 동안만 데이터를 기억하는 휘발성 메모리(volatile memory)이다. 또한 DRAM은 메인 메모리(main memory 또는 primary memory)로 사용된다. 메모리 계층구조에서 메인 메모리보다 한 단계 아래 계층에는 컴퓨터가 꺼져있을 때도 데이터를 저장하는 비휘발성 메모리(nonvoltile memory)인 보조기억장치(secondary memory)가 있다.

<br>
(이 부분 갑자기 너무 뜬금없이 나오는 것 같음.) <br>
명령어 집합 구조(instruction set architecture, 혹은 그냥 구조라고도 함.)은 하드웨어와 최하위 계층 소프트웨어 사이의 인터페이스, 명령어, 레지스터, 메모리 접근, 입출력 등을 포함해서 정확히 작동하는 기계어 프로그램을 작성하기 위해서 알아야 하는 모든 정보를 말한다. <br>
ABI(application binary interface)는 명령어 집합 중 사용자 부분과 응용 프로그래머가 사용하는 운영체제 인터페이스를 합친 것을 말한다.

**컴퓨터 간의 통신**

- 근거리 네트워크(LAN, local area network): 지리적으로 제한된 지역에서 데이터를 주고받도록 설계된 네트워크. 가장 널리 알려진 것은 이더넷(Ethernet)
- 원거리 네트워크(WAN, wide area network): 대륙 전체를 연결할 수 있는 수백 km 이상의 네트워크

## 1.5 프로세서와 메모리 생산 기술

컴퓨터 전문가라면 집적회로에 대한 기초적인 내용을 알고 있어야 한다는데, 그렇다면 나는 몰라도 되는거 아닌가?

실리콘에 특수한 화학적 처리를 하면 도체, 절연체, 조건에 따라 도체가 되기도 하고 절연체가 되기도 하는 스위치 중 하나로 바꿀 수 있다. 트랜지스터는 스위치에 해당한다. VLSI 회로는 수십억 개의 도체, 절연체, 스위치들을 작은 패키지 하나에 만들어 넣은 것이다. <br>
<br>
집적회로 제조 공정은 다음과 같다. 실리콘 결정 괴를 웨이퍼로 만들고, 웨이퍼의 부분 부분을 트랜지스터, 도체, 절연체로 바꾸고, 그 다음 웨이퍼를 컴포넌트별로 자른다. 이것을 다이(die) 또는 칩이라고 한다.<br>
<br>
결함이 없는 다이는 패키지의 입출력 핀과 연결하는데 이 과정을 본딩(bonding)이라고 한다. 그리고 패키지가 끝난 것들 중에서 최종 검사에 통과된 것들만 납품된다.

- 트랜지스터(transistor): 전기 신호로 제어되는 온/오프 스위치. 칩 안에 집적되는 트랜지스터의 수가 빠르게 늘어날 것이라는 게 Moore의 예측.
- 초대규모집적회로(VLSI: very large scale integrated circuit): 수십만 내지 수백개의 트랜지스터를 포함하고 있는 장치.
- 수율(yield): 웨이퍼 상의 전체 다이 중 양호한 다이의 비율.

## 1.6 성능

**성능의 정의**

경우에 따라 응답시간이 중요할 수도 있고, 처리량이 중요할 수도 있다.

- 응답시간(response time): 실행시간(execution time)이라고도 한다. 컴퓨터가 태스크를 완료하기까지의 총 소요시간으로 디스크 접근, 메모리 접근, 입출력 작업, 운영체제 오버헤드 및 CPU시간을 다 포함한다.
- 처리량(throughput): 대역폭(bandwidth)이라고도 한다. 단위시간당 완료하는 태스크의 수를 나타내는 또 다른 성능 척도.

어떤 컴퓨터 $X$의 성능과 실행시간의 관계를 다음과 같이 표시할 수 있다.
$$
\text{성능}_X = \frac{1}{\text{실행시간}_X}
$$
그러므로 두 컴퓨터 $X$와 $Y$에 대해 $X$의 성능이 $Y$의 성능보다 좋다면, 다음과 같은 부등식이 성립한다.
$$
text{성능}_X > text{성능}_Y \qquad \text{실행시간}_Y > \text{실행시간}_X.
$$
또한 $X$가 $Y$보다 $n$배 빠르다면, $Y$의 실행시간이 $n$배 길 것이고, 다음과 같이 쓸 수 있다.
$$
\ \frac{text{성능}_X}{text{성능}_Y} = \frac{\text{실행시간}_Y}{\text{실행시간}_X} = n.
$$

**성능의 측정**

- CPU 실행시간(CPU execution time): CPU 시간(CPU time)이라고도 한다. 특정 작업의 실행을 위해 CPU가 소비한 실제 시간. 입출력에 걸린 시간이나 다른 프로그램을 실행하는 데 걸린 시간은 여기 포함되지 않는다. 사용자 CPU 시간과 시스템 CPU 시간(system CPU time)으로 나뉜다.
- 사용자 CPU 시간(user CPU time): 프로그램 자체에 소비된 CPU 시간
- 시스템 CPU 시간(system CPU time): 프로그램의 수행을 위해서 운영체제가 소비한 CPU 시간

하드웨어가 기본 함수를 얼마나 빨리 처리할 수 있는지와 관련된 성능 척도는 클럭을 이용하여 만들어진다.

- 클럭 사이클: 틱, 클럭 틱, 클럭 주기, 클럭, 사이클이라고도 한다. 일정한 속도를 가지고 동작하는 프로세서 클럭 한 주기 동안의 시간.
- 클럭 주기(clock period): 한 클럭 사이클에 걸리는 시간
- 클럭 속도: 클럭 주기의 역수. Hz로 표시한다.

**CPU 성능과 성능 인자**

$$
\text{프로그램의 CPU 실행시간} = \text{프로그램의 CPU 클럭 사이클 수} \times \text{클럭 사이클 시간} = \frac{\text{프로그램의 CPU 클럭 사이클 수}}{\text{클럭 속도}}
$$

**명령어 성능**

$$
\text{CPU 클럭 사이클 수} = \text{명령어 수} \times \text{명령어당 평균 클럭 사이클 수}
$$
명령어당 클럭 사이클 수(clock cycles per instruction)는 CPI로 줄여 쓰기도 한다. 명령어마다 실행시간이 다르므로 CPI는 프로그램이 실행한 모든 명령어에 대해 평균한 값을 사용한다. 명령어 집합 구조가 같으면 프로그램에 필요한 명령어 수가 같으므로, CPI는 서로 다른 구현을 비교하는 한 가지 기준이 될 수 있다.

**고전적인 CPU 성능식**

$$
\text{CPU 시간} = \text{명령어 개수} \times \text{CPI} \times \text{클럭 사이클 시간} = \frac{\text{명령어 개수} \times \text{CPI}}{\text{클럭 속도}}
$$
명령어 개수(instruction count)는 프로그램이 실행한 명령어의 개수를 말한다.

<br>
성능식의 세 가지 인자 값은 어떻게 구할까? CPU 실행시간은 실제 프로그램을 실행시켜서 얻을 수 있고, 클럭 사이클 시간은 보통 컴퓨터의 하드웨어 메뉴얼에 기록되어 있다. 그러나 명령어 개수와 CPI는 구하기가 조금 어렵다. 물론 클럭 속도와 CPU 실행시간을 알 때, 명령어 개수나 CPI 중 하나를 알면 다른 하나는 계산으로 구할 수 있다. <br>
<br>
명령어 개수는 실행 과정을 추적하는 소프트웨어 도구나 컴퓨터 구조의 시뮬레이터를 이용해서 측정할 수 있다. 그 외에 하드웨어 카운터를 사용하면 실행 명령어 수나 평균 CPI, 심지어는 성능 저하의 원인도 찾아낼 수 있다. 명령어 개수는 구조에 따라 결정될 뿐 구현 방법과는 상관이 없다. <br>
<br>
반면에 CPI는 프로그램 실행에 사용되는 명령어 배합(instruction mix)뿐 아니라 메모리 시스템과 프로세서 구조를 포함하는 여러 컴퓨터 세부 설계에 따라 달라진다.<br>
<br>
따라서 여러 인자들 끼리 비교해서 성능을 평가해야 한다.

**프로그램 성능의 이해**

응용에 따라서 컴퓨터 시스템의 성능 중 민감하게 영향을 받는 부분이 서로 다르다. 프로그램의 성능을 개선하기 위해서는 어떤 성능 척도들이 중요한지를 먼저 명확히 정의한 다음, 프로그램을 수행시키면서 성능을 측정함으로써 병목이 될 가능성이 있는 부분을 조사한다.

| 하드웨어 또는 소프트웨어 구성 요소 | 영향을 끼치는 인자 | 어떻게? |
|:----------:|:----------:|:----------:|
| 알고리즘 | 명령어 개수, CPI | 알고리즘은 소스 프로그램이 수행할 명령어의 수, 결국 프로세서가 수행할 명령어의 수를 결정한다. 알고리즘이 빠른 명령어를 선호하느냐 느린 명령어를 선호하느냐에 따라  CPI에 영향을 미칠 수도 있다. |
| 프로그래밍 언어 | 명령어 개수, CPI | 프로그래밍 언어로 푠현된 문장은 프로세서 명령어로 변환되기 때문에 확실히 명령어 개수에 영향을 미치게 된다. 또 언어의 어떤 특성 때문에 언어가 CPI에도 영향을 미칠 수 있다. |
| 컴파일러 | 명령어 개수, CPI | 컴파일러는 소스 언어를 컴퓨터 명령어로 변환하는 역할을 하므로 얼마나 효율적인가에 따라 명령어 개수와 CPI가 영향을 받는다. |
| 명령어 집합구조 | 명령어 개수, 클럭 속도, CPI | 명령어 집합 구조는 어떤 기능을 수행하기 위해 필요한 명령어의 수, 각 명령어당 사이클의 수, 그리고 프로세서의 클럭 속도에 영향을 미치므로 CPU 성능의 세 인자에 모두 영향을 미친다. |

## 1.7 전력 장벽

클럭 속도와 소비 전력은 오랫동안 빠르게 증가하다 최근에 주춤해졌다. 속도와 전력은 서로 연관되어 있는데, 상용 마이크로프로세서의 냉각 문제 때문에 실제로 사용할 수 있는 전력이 한계에 도달했기 때문이다. <br>
<br>
1982년부터 2012년까지 전력은 30배 증가한데 비해 클럭 속도는 1000배나 빨라졌는데, 이는 새로운 공정기술으로 전압이 낮아졌기 때문이다. 전력은 전압의 제곱에 비례하기 때문에 소비전력이 낮아졌다. 하지만 전압을 더욱 낮추게 되면 트랜지스터 누설 전류가 너무 커지는 문제가 생기는데, 이는 꽉 잠기지 않는 수도꼭지의 문제와 같다. <br>

<br>
집적회로의 주된 기술인 CMOS(complementary metal oxide semiconductor)가 에너지를 소비하는 주원인은 동적 에너지(dynamic energy)이다. 동적 에너지란 트랜지스터가 0에서 1로 혹은 그 반대로 스위칭하는 동안에 소비되는 에너지를 말한다. 동적 에너지는 각 트랜지스터의 용량성 부하와 인가되는 전압에 의해 결정된다.
$$
\text{에너지} \propto \text{용량성 부하} \times \text{전압}^2
$$
이 식은 $0 \rightarrow 1 \rightarrow 0$ 혹은 $1 \rightarrow 0 \rightarrow 1$으로 논리 값이 두 번 바뀔 때 소모하는 에너지이다. 한 번 바뀔 때 소모되는 에너지는 다음과 같다.
$$
\text{에너지} \propto \frac{1}{2} \times \text{용량성 부하} \times \text{전압}^2
$$
트랜지스터 하나가 소비하는 전력은 한 번 바뀔 때 소모되는 에너지와 시간당 논리 값이 바뀌는 빈도수의 곱이다.
$$
\text{전력} \propto \frac{1}{2} \times \text{용량성 부하} \times \text{전압}^2 \times \text{스위칭 빈도}
$$
스위칭 빈도는 클럭 속도의 함수이다. 트랜지스터의 용량성 부하는 출력 단자에 연결된 트랜지스터의 개수(팬아웃, fan out, 이라고 한다.)와 공정기술의 함수이다. 공정기술은 도선과 트랜지스터의 용량(capacitance)을 결정한다.

## 1.8 현저한 변화: 단일 프로세서에서 멀티프로세서로의 변화

전력 한계 문제는 마이크로프로세서 설계에 극적인 변화를 가져왔다. 단일 프로세서에서 한 프로그램의 응답시간을 계속 줄여 나가는 대신, 칩에 여러 개의 프로세서를 집적한 마이크로프로세서를 생산하기 시작한 것이다. 이는 응답시간보다는 처리량 개선에 더 효과가 있다. <br>
<br>
프로세서와 마이크로프로세서 두 용어 사이의 혼란을 줄이기 위하여 프로세서를 '코어'라고 부르고, 마이크로프로세서를 멀티코어 마이크로프로세서라고 부른다. 예를들어 '쿼드코어' 마이크로프로세서는 4개의 프로세서를 포함한 칩이다. <br>
<br>
과거에는 하드웨어와 컴퓨터 구조, 그리고 컴파일러의 혁신에만 의존하여도 18개월마다 2배씩의 성능 개선을 누릴 수 있었다. 하지만 오늘날 응답시간을 현저히 개선하려면 다중 프로세서의 장점을 살려야 한다.

## 1.9 실례: Intel Core i7 벤치마킹

## 1.10 오류 및 함정

**오류**

- 이용률이 낮은 컴퓨터는 전력 소모가 작다.
- 성능에 초점을 둔 설계와 에너지 효율에 초점을 둔 설계는 서로 무관하다.

**함정**

- 컴퓨터의 한 부분만 개선하고 그 개선된 양에 비례해서 전체 성능이 좋아지리라고 기대하는 것
- 성능식의 일부분을 성능의 척도로 사용하는 것

Amdahl의 법칙은 어떤 개선책으로부터 얻을 수 있는 성능의 증가는 개선된 부분이 얼마나 많이 사용되느냐에 따라 제한된다는 법칙이다. 식으로는 다음과 같이 표현할 수 있다.
$$
\text{개선 후 실행시간} = \frac{\text{개선에 의해 영향을 받는 실행시간}}{\text{개선의 크기}} + \text{영향을 받지 않는 실행시간}
$$

실행시간 대신에 쓸 수 있는 척도 중 하나로 MIPS(million instructions per second)가 있다. MIPS는 프로그램의 실행속도를 백만 개의 명령어 단위로 나타내는 척도이다.
$$
\text{MIPS} = \frac{\text{명령어 개수}}{\text{실행시간} \times 10^6} = \frac{\text{명령어 개수}}{\frac{\text{명령어 개수} \times \text{CPI}}{\text{클럭 속도}} \times 10^6} = \frac{\text{클럭 속도}}{\text{CPI} \times 10^6}
$$

## 1.11 결론
